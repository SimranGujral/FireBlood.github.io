---
title: "Modernizing the TLS stack on Servo"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width="750px", dpi=300)
```
## Background and Motivation

Servo, Mozilla's parallel browser engine is written in Rust. Servo aims to create a browser which is memory safe and fast, 
the next generation browser.Before I get to what this post is about, I think its worthwhile to explain the jargon surrounding 
it. I think it is important to explain why TLS is so important, what is RusTLS, why the effort to integrate RusTLS and Servo 
is important.I believe the answers to these questions form the motivation for this project. 

Every time your browser connects to a website, rather, before your browser connects to a website, it performs a 9 step handshake by 
means of which it makes sure that your connection to the website is secure and the parties involved in the communication are 
not malicious. This is basically the SSL/TLS protocol. 
Every browser has its own version of the TLS protocol. As of today, Servo uses Rust-OpenSSL. 
Now, as I mentioned earlier, Servo is the supposed to be next generation browser which is written in Rust- which is inherently type 
safe and memory safe. However, its TLS stack is Rust-OpenSSL, which is basically Rust bindings for OpenSSL which is written in C 
and Assembly. One of the discussions in the Servo community has been to move to Rust Based crypto primitives for Servo's 
TLS stack.

We had a couple of things we had in mind, one was to make the certificate verification process parallel, to use a certificate verification library based on Rust based Crypto primitives, to make the TLS stack much leaner (in essence this meant removing features which we did not need in a browser today. Over the years, the OpenSSL TLS stack has developed with the browser. During this process, a 
lot of things have come into existence and a lot of things have become obsolete. Hence, it makes sense to clean what we did not need anymore.).

## Concepts
#### BoringSSL
BoringSSL is Google's fork of OpenSSL and was created in response to the Heartbleed bug found in OpenSSL.
It had the absolute necessary features which Google required for their use.
#### Ring
Ring is a fork of BoringSSL which was written in Rust. It is a set of rust cryptographic primitives which are based of BoringSSL.
#### WebPKI
WebPKI is a certificate verification library which works on Ring. It uses rings cryptographic primitives for certificate verification.
#### Rustls
Rustls is the TLS stack written in Rust which uses WebPKI for certificate verification. 
#### Hyper-Rustls
Hyper is a networking library. As Hyper-Rustls it uses Rustls to make its connections secure. Hyper-Rustls works as a connection between Hyper- a networking library and Rustls - a TLS implementation to make network connections secure.

Hence, it goes like this :

<img src="https://github.com/SimranGujral/FireBlood.github.io/blob/master/RustlsDependencyChart.png"></img>

<b>Figure 1 : </b>Rustls --> WebPKI --> Ring --> BoringSSL

For more Information:
<ul>
<li><a href="https://boringssl.googlesource.com/boringssl/">BoringSSL</a></li>

<li><a href="https://github.com/briansmith/ring">Ring</a></li>

<li><a href="https://github.com/briansmith/webpki">WebPKI</a></li>

<li><a href="https://github.com/ctz/rustls">RusTLS</a></li>

<li><a href="https://github.com/ctz/hyper-rustls">Hyper-RusTLS</a></li>
</ul>

## Concerns
So, this is how all the pieces of the puzzle fit together, and now we have to fit them into Servo.

However, when you set out to make a browser which is blazingly fast, you need to make sure that any piece you fit in does not slow it down.

Also, when the primary concern for your blazingly fast browser is security, you want to make sure the cryptographic protocols in the new 
version of the TLS stack that you use work correctly. 

Lastly, since you want to move to a leaner version, you want to try to make sure that  the stack supports most of the features that the web depends on. 

Hence, we come down to our three main concerns pre-integration:

1) Does Rustls support the most important and most of the features that the web needs and depends on?

2) Do these features work without glitches?

3) Is it fast enough, if not faster?

## Pre-Integration

There were two things we did to handle our concerns:
1) Feature Comparison between RusTLS and Rust-OpenSSL
2) Performance Comparison between RusTLS and Rust-OpenSSL

## Feature Comparison

This was important to handle concerns 1 and 2 and was done using the BoringSSL test suite. The BoringSSL test suite is basically a suite of unit tests which was designed for BoringSSL and can be used to check TLS implementations.
There is already a shim to test the TLS implementation for RusTLS.
It can be found here:

<a href="https://github.com/ctz/rustls/tree/master/examples/internal">RusTLS BoGo Shim</a>

I worked on a TLS implementation for Rust-OpenSSL to understand the difference in libraries and features between the two TLS implementations and tested this against the BoringSSL test suite.
The shim does not currently support all features tested by the BoringSSL test suite.
It does not pass all the tests posed by the BoringSSL test suite. However, this is not because the library is incorrect, its because the BoringSSL test suite was designed was BoringSSL and we are testing it on Rust-OpenSSL. The errors reported by Rust-OpenSSL are different in wording than the ones expected by the suite and this leads to failures inspite of the shim behaving correctly.
Currently the shim passes 245 tests and fails 251. 
This is still a work in progress.
However, this implementation greatly helped me in understanding the differences in the two libraries.


As I mentioned earlier, RusTLS already has a TLS implementation to be tested against the suite. RusTLS passes all tests it is being tested against in the BoringSSL test suite. A major point of concern which emerged for us during these tests was that RusTLS does not support TLS v 1.0 and TLS v 1.1. It also does not support DHE and SHA1 which Servo was using, but wanted to remove this dependency as per this issue:

https://github.com/servo/servo/issues/8581

https://github.com/servo/servo/pull/16535


## Performance Comparison

For the performance comparison, I created a benchmarking framework for Hyper-Rustls















FAQs:

1) Why doesn't Servo use NSS?

A: There are no Rust Bindings for NSS. There exist Rust Bindings for OpenSSL. Hence, we use that.

